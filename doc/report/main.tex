\documentclass{report}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage[a4paper,
            inner=30mm, outer=20mm,
            top=25mm, bottom=25mm,
            headheight=15mm, headsep=7mm
            ]{geometry}
            
\usepackage[french]{babel}
\usepackage{csquotes}
\usepackage[style=numeric-comp]{biblatex}
\usepackage{graphicx}
\usepackage{todonotes}

\usepackage{color}
\definecolor{lstgrey}{rgb}{0.95,0.95,0.95}
\usepackage{listings}
\lstset{language=C,
       backgroundcolor=\color{lstgrey},
       frame=single,
       basicstyle=\footnotesize\ttfamily,
       captionpos=b,
       tabsize=2,
     }
     
\addbibresource{references.bib}% Syntax for version >= 1.2

\begin{document}

\input{title.tex}

\tableofcontents

\chapter{Le projet}

Ce projet s'inscrit dans la continuité de précédents PSTLs. L'objectif
principal est d'étendre les fonctionnalités actuelles vers une API réactive.

YAW (Yet Another World) est une bibliothèque Java, développée au fil de plusieurs
PSTL, de manipulation et affichage d'objets 3D avec une surcouche Clojure.
L'objectif de ce projet est de trouver un moyen d'offrir une interface de
programmation interactive permettant de facilement développer des applications
3D de façon déclarative.

\chapter{Remerciements}

\chapter{YAW: code existant}

YAW est une bibliothèque Java/Clojure de rendu et manipulation 3D faisant principalement
interface avec OpenGL.

OpenGL est une bibliothèque de rendu très bas-niveau,
manipulant des points et des triangles, sans aucune notion d'objets ou de
transformations telles que des rotations ou translations.
YAW offre ces fonctionnalités de manipulation de plus haut niveau, tout en
gardant le contrôle de l'utilisateur sur la géométrie des objets manipulés.

\section{Interface Java}

\subsection{La classe \lstinline|World|}
L'interface publique Java de YAW est principalement accédée par la classe
\lstinline|World|.

Cette classe représente un fenétre sur un espace 3D et sa population.
Le listing \ref{lst:worldclass} liste quelques méthodes proposées par cette
classe.

Un processus notable est celui d'ajout d'un objet 3D dans la scène.
L'objet (dans le code \emph{item}) est inséré dans le monde avec un nom, une
position et une échelle, et un \emph{mesh}.
Ce \emph{mesh} est aussi créé via une méthode de \lstinline|World| avec les
données bas-niveau de géométrie requises par OpenGL.

Cette classe propose un nombre de méthodes d'altération de la scène directement,
à l'exception des lumières, qui nécessitent de récupèrer la
\lstinline|SceneLight| et d'interagir avec.

\begin{lstlisting}[caption=Interface incomplète de la classe World, label={lst:worldclass},language=Java]
  public class World implements Runnable {
    // ... implementation de Runnable omise, il s'agit de la gestion de la
    //     fenetre.
    
    public World(int pInitX, int pInitY, int pInitWidth, int pInitHeight);
    
    public Item createItem(String id, float[] pPosition, float pScale, Mesh
    pMesh);

    public Mesh createMesh(float[] pVertices, float[] pTextCoords, float[]
    pNormals, int[] pIndices, int pWeight, float[] rgb, String
    pTextureName);
         
    public Item createBoundingBox(String id, float[] pPosition, float pScale,
    float[] pLength);
    
    public boolean isInCollision(Item item1, Item item2);
    
    public void setSkybox(float pWidth, float pLength, float pHeight, float pR,
    float pG, float pB);
    public void removeSkybox();

    public SceneLight getSceneLight();
   
    public void addCamera(int pIndex, Camera pCamera);
 
    //... reste omis
  }
\end{lstlisting}

\subsection{Les lumières}

\begin{lstlisting}[caption=Interface incomplète de la classe SceneLight, label={lst:lightsclass},language=Java]
  public class SceneLight {
    public static final int MAX_POINTLIGHT = 5;
    public static final int MAX_SPOTLIGHT = 5;
 
    public SceneLight();
     
    public void removeAmbient();
    
    public void removeSun();
   
    public void setPointLight(PointLight pl, int pos);
    
    public void setSpotLight(SpotLight sl, int pos);
 
    public DirectionalLight getSun();
    public void setSun(DirectionalLight sun);
    
    public AmbientLight getAmbientLight();
    public void setAmbient(AmbientLight ambient);
   
    //... reste omis
  }
\end{lstlisting}

La gestion des lumières se fait à travers une instance de la classe
\lstinline|SceneLight|, présentée partiellement en listing
\ref{lst:lightsclass}.

Il est possible d'avoir jusqu'à \lstinline|MAX_POINTLIGHT| sources de lumières
ponctuelles, et jusqu'à \lstinline|MAX_SPOTLIGHT| projecteurs.

Contrairement à la création des objets dans \lstinline|World|, la création des lumières se
fait directement par constructeur.

\section{Interface Clojure}

L'interface Clojure de YAW est une interface quasiment traduite. Un fichier
\texttt{world.clj} comporte un ensemble de fonctions appelant directement les
méthodes de la classe \lstinline|World|.

\begin{lstlisting}[caption=Interface initiale simplifiée de \texttt{world.clj},label={lst:worldclj},language=Lisp]
  
  (defn start-universe! [& {:keys [width height x y]}] (...))
  
  (defn create-mesh! [world & {:keys [vertices text-coord normals faces weight
    rgb texture-name]}] (...))
  
  (defn create-item! [world & {:keys [id position scale mesh]}] (...))

  (defn create-block! [world & {:keys [id position scale color texture]}] (...))

  (defn create-bouding-box! [world & {:keys [id position length scale]}] (...))
  (defn add-bounding-box! [item bounding-box] (...))
  (defn check-collision! [world item1 item2] (...))

  (defn rotate! [item & {:keys [x y z]} (...))
  (defn translate! [item & {:keys [x y z]} (...))
  
\end{lstlisting}

Les fonctions clojure présentée en listing \ref{lst:worldclj} ont été
simplifiées par souci de brièveté: les arguments suivant les esperluettes sont
optionels et ont des valeurs par défaut.
Ces fonctions ont un point d'exclamation à la fin de leur nom, ce qui dans la
communauté Clojure a été accpeté comme convention pour signifier qu'une fonction
a des effets de bords sur la mémoire et n'est pas \og thread-safe.\fg{}

L'interface est incomplète, manque la gestion des lumières, des caméras, et
d'autres fonctionnalités diverses offertes par la bibliothèque Java.

\chapter{Recherche}

\section{Inspirations initiales}
\subsection{React}

\subsection{Unity}
\section{Reagent}
\section{Re-frame}

\chapter{Fonctionnalités}
\section{Programmation fonctionnelle réactive}
\subsection{Objectif}
\subsection{Plan de réalisation}
\subsection{Problèmes}
\section{Moteur de jeu}
\subsection{Objectif}
\subsection{Plan de réalisation}
\subsection{Problèmes}
\section{Live Coding}
\subsection{Objectif}
\subsection{Plan de réalisation}
\subsection{Problèmes}

\chapter{Conclusion}


\printbibliography

\end{document}